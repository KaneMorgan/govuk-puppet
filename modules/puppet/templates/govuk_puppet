#!/bin/bash
#set -eu

# Re-exec self with sudo if not root.
if [ "$(id -u)" -ne "0" ]; then
  exec sudo "$BASH_SOURCE" "$@"
fi

START_TIME=`date +%s%3N`

listlocks() {

	#list all current locks, date, name, reason, identifier
        #simplify this structure. push the date and a (kind of) 
	#uuid to the filename. Keep the reason, name and uuid as
	#the lockfile content

	if ls *.lock 1> /dev/null 2>&1; then

        	for filename in *.lock
               	 	do
               	        	line=$(head -n 1 "$filename") #Grab file contents
               	         	echo "$filename : $line"
               	 	done
        	echo

	else
		echo "No lock files present"
	fi

}

do_puppet() {

	# Allow return code 2 in case -v/--detailed-exitcodes is passed.
	RBENV_VERSION=1.9.3 /usr/local/bin/govuk_setenv default puppet agent --onetime --no-daemonize "$@" || [ $? -eq 2 ]

	TIME_TOOK=$((`date +%s%3N`-START_TIME))
	echo "<%= @fqdn_metrics %>.puppet.run_duration:${TIME_TOOK}|ms" | nc -w 1 -u localhost 8125

	# We should only reach here if a last_run_summary was written.
	/usr/local/bin/puppet_passive_check_update >/dev/null
	exit 0;

}


usage() {

	programname=$0

	echo "usage: $programname"
	echo "	list-locks : show all current locks "
	echo "	remove-lock: remove one lock, takes numeric identifier as parameter "
	echo "	disable: add a lock "
	echo "	enable: remove all locks "

	exit 1

}

PUPPET_STATE_DIR=`puppet config print statedir`
GOVUK_STATE_DIR="$PUPPET_STATE_DIR/govuk"

#make it if it isn't
[ -d $GOVUK_STATE_DIR ] || mkdir "$GOVUK_STATE_DIR"

#change working directory or die
cd "$GOVUK_STATE_DIR" || { echo "Unable to access locks directory: '$GOVUK_STATE_DIR'" 1>&2 ; exit 1; }

echo "State directory:" "$GOVUK_STATE_DIR"
echo

case $1 in

disable)

	#require a reason, determine a name
	#append a datetime stamp to assist in locating old / forgotten locks
	#write the lockfile containing the reason and name, then 
	#do puppet agent --disable

	LOCK_DATE=`date +%Y-%m-%d`	

	#Capture initial login user
	IAM=`who -am | awk '{ print $1 }'`

	#Capture a reason
	read -p "Please enter reason: " -r

	# Check if string is empty using -z
	if [[ -z "$REPLY" ]]; then
   		echo "Reason required; exiting."
   	exit 1;

	else
   	#Create the lock
		MYID=`date +%s`
		LOCKFILE=puppet_disable_lock.$IAM.$LOCK_DATE.$MYID.lock
		echo "Creating $LOCKFILE .."
		touch $LOCKFILE || { echo "Unable to create lock  '$LOCKFILE'" 1>&2 ; exit 1; }
		echo "$REPLY - $MYID" >> $LOCKFILE
		do_puppet #Disable puppet agent - helpfully the parameter required is the same
	fi
	
	exit 0;
	;;

list-locks)

	listlocks;
	exit 0;
	;;
		
remove-lock)

	#remove lock by identifier - check the identifier is actually in the file
	#to stop any accidental rm's from happening, though the suffix and cwd are
	#probably sufficient.


	#TODO
	#If it is the last lock being removed, call puppet agent --enable

	MYID=$2

	if [ -z "$MYID" ] #If no identifier is passed, exit.
	then
		echo "Identifier required; exiting.."
		exit 1;
	fi

	if ls *.$MYID.lock 1> /dev/null 2>&1; then #if the lock exists remove it

		for filename in *.$MYID.lock
                	do
				#if [ ! -z $(grep "$MYID" $filename) ]; then
					rm $filename && echo "Removed lock: $filename";
				#fi
                	done

		#Now check if it any locks remain. If not, re-enable puppet agent.

		if ls *.lock 1> /dev/null 2>&1; then #there are more locks

			exit 0;

		else #there are no locks left, re-enable

			# Allow return code 2 in case -v/--detailed-exitcodes is passed.
        		RBENV_VERSION=1.9.3 /usr/local/bin/govuk_setenv default puppet agent --onetime --no-daemonize "$@" || [ $? -eq 2 ]

        		TIME_TOOK=$((`date +%s%3N`-START_TIME))
        		echo "<%= @fqdn_metrics %>.puppet.run_duration:${TIME_TOOK}|ms" | nc -w 1 -u localhost 8125

        		# We should only reach here if a last_run_summary was written.
        		/usr/local/bin/puppet_passive_check_update >/dev/null
        		exit 0;

		fi
	
		exit 0;
	
	else
		echo "No lock with identifier: $MYID found. Exiting.."
		exit 1;
	fi

	;;

enable)

	#iterate over lockfiles and remove all of them
	#(require a confirmation after calling list-locks)
	
	listlocks;
	read -p "Are you sure? (y/n): " -n 1 -r
	echo    # (optional) move to a new line
	if [[ $REPLY =~ ^[Yy]$ ]]
	then
		for filename in *.lock
		do
                	rm $filename
               		echo "Removed: $filename"
        	done
		do_puppet
	fi
	exit 0;
	;;


help)

	usage
	exit 0;
	;;

*)

	#Everything else just pass it through
	do_puppet
	exit 0;
	;;

esac
